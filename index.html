<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mutations ‚Äî Crafting Tree</title>
  <style>
    :root { color-scheme: dark; }
    * { box-sizing: border-box; }
    body { margin: 0; font: 14px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background:#0b0f17; color:#e7ecff; }
    header { position: sticky; top: 0; z-index: 10; background: rgba(11,15,23,.92); backdrop-filter: blur(10px); border-bottom: 1px solid rgba(255,255,255,.08); }
    .wrap { max-width: 1200px; margin: 0 auto; padding: 14px; }
    .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .title { font-weight: 800; letter-spacing: .2px; }
    .pill { display:inline-flex; gap:8px; align-items:center; padding:8px 10px; border-radius:999px; border:1px solid rgba(255,255,255,.12); background: rgba(255,255,255,.04); }
    input, button {
      background: rgba(255,255,255,.06);
      color: inherit;
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 10px;
      padding: 8px 10px;
      outline: none;
    }
    input { width: 340px; }
    button { cursor:pointer; }
    button:hover { background: rgba(255,255,255,.10); }
    button:disabled { opacity:.45; cursor:not-allowed; }
    .hint { opacity:.72; font-size: 12px; }

    main { max-width: 1200px; margin: 0 auto; padding: 14px; display:grid; gap:12px; }
    .panel { border:1px solid rgba(255,255,255,.10); background: rgba(255,255,255,.03); border-radius:16px; overflow:hidden; }
    .panelHead { padding:10px 12px; border-bottom:1px solid rgba(255,255,255,.08); display:flex; justify-content:space-between; align-items:center; gap:10px; }
    .status { font-size:12px; opacity:.8; }
    #viz { width:100%; height:74vh; display:block; }

    /* Tooltip: NOT interactive; hides instantly */
    .tooltip {
      position: fixed;
      padding: 10px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(11,15,23,.97);
      box-shadow: 0 10px 30px rgba(0,0,0,.45);
      max-width: 720px;
      transform: translate(10px, 10px);
      display: none;
      pointer-events: none;
    }
    .tooltip .name { font-weight: 900; font-size: 14px; margin-bottom: 6px; }
    .tooltip .meta { font-size: 12px; opacity: .9; display:grid; gap:4px; }
    .tooltip .sep { height:1px; background: rgba(255,255,255,.10); margin: 8px 0; }
    .tooltip ul { margin: 0; padding-left: 16px; }

    .gridTitle { font-size:12px; opacity:.85; margin: 6px 0; }
    .gridAny { display:grid; gap:6px; margin-top:6px; }

    .cell {
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 10px;
      background: rgba(255,255,255,.04);
      padding: 6px 7px;
      min-width: 120px;
    }
    .slotNum { font-size: 11px; opacity:.7; }
    .slotVal { font-size: 12px; margin-top: 2px; font-weight: 650; }
    .slotVal.small { font-weight: 550; opacity:.9; }

    /* plant footprint highlight */
    .cell.plantArea {
      border-color: rgba(80, 255, 140, .38);
      background: rgba(80, 255, 140, .07);
      box-shadow: 0 0 0 1px rgba(80, 255, 140, .12) inset;
    }
    /* main label cell highlight (the ‚Äúresult‚Äù) */
    .cell.centerMain {
      border-color: rgba(80, 255, 140, .70);
      background: rgba(80, 255, 140, .12);
      box-shadow: 0 0 0 1px rgba(80, 255, 140, .22) inset;
    }
    .cell.centerMain .slotVal { color: rgba(120, 255, 170, .95); }

    .tag {
      display:inline-block;
      padding:2px 8px;
      border:1px solid rgba(255,255,255,.14);
      border-radius:999px;
      font-size: 12px;
      opacity:.92;
      margin-left: 8px;
    }
    .link { color: inherit; text-decoration: none; border-bottom: 1px dotted rgba(255,255,255,.35); }

    .gold { color: #ffd56a; font-weight: 800; }
  </style>
</head>
<body>
<header>
  <div class="wrap">
    <div class="row" style="justify-content:space-between;">
      <div class="row">
        <div class="title">üåø Mutations Crafting Tree</div>
        <div class="hint">Search ‚Üí Enter. Hover circles for info (hides instantly). Click mutation circles to drill in. Ctrl+Z = Go back to baseline.</div>
      </div>
      <div class="hint" id="counts">‚Äî</div>
    </div>

    <div class="row" style="margin-top:10px;">
      <div class="pill">
        <input id="search" list="mutList" placeholder="Search mutation‚Ä¶ (e.g. Timestalk)" />
        <datalist id="mutList"></datalist>
        <button id="go">Go</button>
        <button id="back" title="Back to the baseline mutation you searched">Go back</button>
      </div>

      <div class="pill">
        <div class="hint">Baseline:</div>
        <div id="baseline" style="font-weight:800;">‚Äî</div>
      </div>

      <div class="pill">
        <div class="hint">Current:</div>
        <div id="current" style="font-weight:800;">‚Äî</div>
      </div>
    </div>
  </div>
</header>

<main>
  <div class="panel">
    <div class="panelHead">
      <div class="status" id="status">Search for a mutation to start.</div>
      <div class="hint">Grid scales with plant size: 1√ó1 ‚Üí 3√ó3, 2√ó2 ‚Üí 4√ó4, 3√ó3 ‚Üí 5√ó5.</div>
    </div>
    <svg id="viz"></svg>
  </div>
</main>

<div class="tooltip" id="tip"></div>

<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script>
(() => {
  const $ = (s) => document.querySelector(s);
  const searchEl = $("#search");
  const listEl = $("#mutList");
  const goBtn = $("#go");
  const backBtn = $("#back");
  const statusEl = $("#status");
  const countsEl = $("#counts");
  const currentEl = $("#current");
  const baselineEl = $("#baseline");
  const tipEl = $("#tip");
  const svg = d3.select("#viz");

  const BASE_CROPS = [
    "Nether Wart","Cocoa Beans","Melon","Pumpkin","Wheat","Carrot","Cactus","Potato","Sugar Cane",
    "Red Mushroom","Brown Mushroom","Sunflower","Wild Rose"
  ];

  // Local dataset (no fetch)
  const MUTATIONS = [
    { name:"Ashwreath", rarity:"COMMON", size:"1x1", surface:"Soul Sand", spread:"4x Nether Wart / 4x Fire", drops:"1200x Nether Wart", effects:"Improved Harvest Boost / XP Loss" },
    { name:"Choconut", rarity:"COMMON", size:"1x1", surface:"Farmland", spread:"4x Cocoa Beans", drops:"800x Cocoa Beans", effects:"Immunity" },
    { name:"Dustgrain", rarity:"COMMON", size:"1x1", surface:"Farmland", spread:"4x Wheat", drops:"400x Wheat", effects:"Harvest Boost" },
    { name:"Gloomgourd", rarity:"COMMON", size:"1x1", surface:"Farmland", spread:"1x Pumpkin / 1x Melon", drops:"170x Pumpkin / 800x Melon Slice", effects:"Water Retain / Bonus Drops" },
    { name:"Lonelily", rarity:"COMMON", size:"1x1", surface:"Farmland", spread:"0 adjacent crops", drops:"600x Potato / 700x Carrot / 340x Pumpkin", effects:"Bonus Drops" },
    { name:"Scourroot", rarity:"COMMON", size:"1x1", surface:"Farmland", spread:"2x Potato / 2x Carrot", drops:"600x Potato / 700x Carrot", effects:"Immunity / XP Boost" },
    { name:"Shadevine", rarity:"COMMON", size:"1x1", surface:"Farmland", spread:"2x Cactus / 2x Sugar Cane", drops:"300x Cactus / 400x Sugar Cane", effects:"Improved Water Retain / Improved XP Boost / Harvest Loss" },
    { name:"Veilshroom", rarity:"COMMON", size:"1x1", surface:"Mycelium", spread:"2x Red Mushroom / 2x Brown Mushroom", drops:"190x Brown Mushroom / 190x Red Mushroom", effects:"Improved Harvest Boost / Water Drain" },
    { name:"Witherbloom", rarity:"COMMON", size:"1x1", surface:"Soul Sand", spread:"8x Dead Plant", drops:"1600x Wild Rose", effects:"Effect Spread" },

    { name:"Chocoberry", rarity:"UNCOMMON", size:"1x1", surface:"Farmland", spread:"6x Choconut / 2x Gloomgourd", drops:"400x Cocoa Beans / 170x Pumpkin / 1600x Melon Slice", effects:"Water Retain" },
    { name:"Cindershade", rarity:"UNCOMMON", size:"1x1", surface:"Soul Sand", spread:"4x Ashwreath / 4x Witherbloom", drops:"1200x Nether Wart / 800x Wild Rose", effects:"Effect Spread / Improved Harvest Boost / XP Loss" },
    { name:"Coalroot", rarity:"UNCOMMON", size:"1x1", surface:"Farmland", spread:"5x Ashwreath / 3x Scourroot", drops:"[More Info Needed]", effects:"XP Boost" },
    { name:"Creambloom", rarity:"UNCOMMON", size:"1x1", surface:"Farmland", spread:"8x Choconut", drops:"[More Info Needed]", effects:"Immunity" },
    { name:"Duskbloom", rarity:"UNCOMMON", size:"1x1", surface:"Farmland", spread:"2x Moonflower / 2x Shadevine / 2x Sunflower / 2x Dustgrain", drops:"[More Info Needed]", effects:"Bonus Drops" },
    { name:"Thornshade", rarity:"UNCOMMON", size:"1x1", surface:"Farmland", spread:"4x Wild Rose / 4x Veilshroom", drops:"[More Info Needed]", effects:"Effect Spread" },

    { name:"Blastberry", rarity:"RARE", size:"1x1", surface:"Sand", spread:"5x Chocoberry / 3x Ashwreath", drops:"[More Info Needed]", effects:"Immunity / Improved Harvest Boost / XP Loss" },
    { name:"Cheesebite", rarity:"RARE", size:"1x1", surface:"Farmland", spread:"4x Creambloom / 4x Fermento", drops:"[More Info Needed]", effects:"Improved Water Retain" },
    { name:"Chloronite", rarity:"RARE", size:"1x1", surface:"Farmland", spread:"6x Coalroot / 2x Thornshade", drops:"[More Info Needed]", effects:"Immunity" },
    { name:"Do-not-eat-shroom", rarity:"RARE", size:"1x1", surface:"Farmland", spread:"4x Veilshroom / 4x Scourroot", drops:"[More Info Needed]", effects:"Improved Harvest Boost / Water Drain" },
    { name:"Fleshtrap", rarity:"RARE", size:"1x1", surface:"Farmland", spread:"4x Cindershade / 4x Lonelily", drops:"[More Info Needed]", effects:"Bonus Drops" },
    { name:"Magic Jellybean", rarity:"RARE", size:"1x1", surface:"Sand", spread:"5x Sugar Cane / 3x Duskbloom", drops:"[More Info Needed]", effects:"Improved XP Boost / Harvest Loss" },
    { name:"Noctilume", rarity:"RARE", size:"2x2", surface:"Farmland", spread:"6x Duskbloom / 2x Lonelily", drops:"[More Info Needed]", effects:"Effect Spread / Improved Water Retain / Harvest Loss" },
    { name:"Snoozling", rarity:"RARE", size:"3x3", surface:"Farmland", spread:"4x Creambloom / 3x Dustgrain / 3x Witherbloom / 3x Duskbloom / 3x Thornshade", drops:"[More Info Needed]", effects:"Bonus Drops" },
    { name:"Soggybud", rarity:"RARE", size:"1x1", surface:"Farmland", spread:"8x Melon", drops:"[More Info Needed]", effects:"Water Retain" },

    { name:"Chorus Fruit", rarity:"EPIC", size:"1x1", surface:"End Stone", spread:"5x Chloronite / 3x Magic Jellybean", drops:"[More Info Needed]", effects:"Improved XP Boost / Harvest Loss" },
    { name:"PlantBoy Advance", rarity:"EPIC", size:"2x2", surface:"Farmland", spread:"6x Snoozling / 6x Thunderling", drops:"[More Info Needed]", effects:"Harvest Boost" },
    { name:"Puffercloud", rarity:"EPIC", size:"1x1", surface:"Farmland", spread:"2x Snoozling / 6x Do-not-eat-shroom", drops:"[More Info Needed]", effects:"Improved Harvest Boost / Water Drain" },
    { name:"Shellfruit", rarity:"EPIC", size:"1x1", surface:"Farmland", spread:"Explode a Turtlellini with a Blastberry.", drops:"[More Info Needed]", effects:"Water Retain / Immunity" },
    { name:"Startlevine", rarity:"EPIC", size:"1x1", surface:"Farmland", spread:"4x Blastberry / 4x Cheesebite", drops:"[More Info Needed]", effects:"Improved Water Retain / Improved XP Boost / Harvest Loss" },
    { name:"Stoplight Petal", rarity:"EPIC", size:"1x1", surface:"Farmland", spread:"4x Snoozling / 4x Noctilume", drops:"[More Info Needed]", effects:"Effect Spread / Improved Water Retain / Harvest Loss" },
    { name:"Thunderling", rarity:"EPIC", size:"1x1", surface:"Farmland", spread:"5x Soggybud / 3x Noctilume", drops:"[More Info Needed]", effects:"Effect Spread" },
    { name:"Turtlellini", rarity:"EPIC", size:"1x1", surface:"Farmland", spread:"4x Soggybud / 4x Choconut", drops:"[More Info Needed]", effects:"Water Retain / Immunity" },
    { name:"Zombud", rarity:"EPIC", size:"1x1", surface:"Soul Sand", spread:"4x Dead Plant / 2x Cindershade / 2x Fleshtrap", drops:"[More Info Needed]", effects:"Effect Spread / Bonus Drops" },

    { name:"All-in Aloe", rarity:"LEGENDARY", size:"1x1", surface:"Sand", spread:"6x Magic Jellybean / 2x PlantBoy Advance", drops:"[More Info Needed]", effects:"Harvest Boost" },
    { name:"Devourer", rarity:"LEGENDARY", size:"1x1", surface:"Farmland", spread:"4x Puffercloud / 4x Zombud", drops:"[More Info Needed]", effects:"Bonus Drops / Improved Harvest Boost / Water Drain" },
    { name:"Glasscorn", rarity:"LEGENDARY", size:"2x2", surface:"Sand", spread:"6x Startlevine / 6x Chloronite", drops:"[More Info Needed]", effects:"Immunity / Improved Water Retain / Harvest Loss" },
    { name:"Godseed", rarity:"LEGENDARY", size:"3x3", surface:"Farmland", spread:"All positive crop effects", drops:"[More Info Needed]", effects:"Improved Harvest Boost / Improved Water Retain / Improved XP Boost / Immunity / Bonus Drops / Improved Effect Spread" },
    { name:"Jerryflower", rarity:"LEGENDARY", size:"1x1", surface:"Farmland", spread:"Grow the Jerryseed", drops:"[More Info Needed]", effects:"[Unknown]" },
    { name:"Phantomleaf", rarity:"LEGENDARY", size:"1x1", surface:"Soul Sand", spread:"4x Chorus Fruit / 4x Shellfruit", drops:"[More Info Needed]", effects:"XP Boost / Immunity" },
    { name:"Timestalk", rarity:"LEGENDARY", size:"1x1", surface:"Soul Sand", spread:"4x Stoplight Petal / 2x Chorus Fruit / 2x Shellfruit", drops:"[More Info Needed]", effects:"Improved Water Retain / Improved XP Boost / Harvest Loss" },
  ];

  const rarityOrder = ["COMMON","UNCOMMON","RARE","EPIC","LEGENDARY","UNKNOWN","BASE","ACTION","ITEM","NPC","LINK"];
  const INDEX = new Map(MUTATIONS.map(m => [m.name, m]));
  const NAMES = [...INDEX.keys()].sort((a,b)=>a.localeCompare(b));
  const mutationNamesSet = new Set(NAMES);

  const SPECIAL_LINE = new Set(["Shellfruit", "Godseed", "Jerryflower"]);
  const DIRT_GUY_URL = "https://hypixel-skyblock.fandom.com/wiki/Dirt_Guy";

  // datalist
  for (const n of NAMES) { const opt = document.createElement("option"); opt.value = n; listEl.appendChild(opt); }

  let BASELINE = null;
  let ROOT = null;

  function safeText(s){ return (s||"").replace(/\s+/g," ").trim(); }
  function setStatus(s){ statusEl.textContent = s; }
  function updateUI(){
    baselineEl.textContent = BASELINE || "‚Äî";
    currentEl.textContent = ROOT || "‚Äî";
    backBtn.disabled = !(BASELINE && ROOT && ROOT !== BASELINE);
  }
  function showTip(html, x, y){
    tipEl.innerHTML = html;
    tipEl.style.left = x + "px";
    tipEl.style.top = y + "px";
    tipEl.style.display = "block";
  }
  function hideTip(){ tipEl.style.display = "none"; }

  function nodeColor(kind, rarity){
    if (kind === "base" || kind === "item") return "rgba(255,255,255,.28)";
    if (kind === "action") return "rgba(255,255,255,.16)";
    if (kind === "npc" || kind === "link") return "rgba(180,210,255,.30)";
    const idx = Math.max(0, rarityOrder.indexOf((rarity||"UNKNOWN").toUpperCase()));
    const a = 0.35 + Math.min(idx, 4) * 0.12;
    return `rgba(231,236,255,${Math.min(a,0.92)})`;
  }

  // --- Parsing for normal recipes ---
  function parseIngredients(spreadLine){
    const line = safeText(spreadLine);
    if (!line) return [];
    if (/0\s+adjacent\s+crops/i.test(line)) return [];
    if (/all\s+positive\s+crop\s+effects/i.test(line)) return [{ name:"All positive crop effects", count: 1 }];
    if (/grow\s+the\s+jerryseed/i.test(line)) return [{ name:"Jerryseed", count: 1 }];

    const parts = line.split("/").map(p => safeText(p)).filter(Boolean);
    const out = [];

    for (const p0 of parts) {
      const p = p0.replace(/[.]+$/,"");
      const m = p.match(/^(\d+)\s*x\s*(.+)$/i);
      if (m) { out.push({ name: safeText(m[2]), count: Number(m[1]) }); continue; }

      const hits = [];
      for (const n of mutationNamesSet) {
        const re = new RegExp("\\b" + n.replace(/[.*+?^${}()|[\]\\]/g,"\\$&") + "\\b", "i");
        if (re.test(p)) hits.push(n);
      }
      if (hits.length) hits.forEach(n => out.push({ name:n, count:1 }));
      else out.push({ name:p, count:1 });
    }

    const merged = new Map();
    for (const it of out) merged.set(it.name, (merged.get(it.name)||0) + (it.count||1));
    return [...merged.entries()].map(([name,count]) => ({name,count}));
  }

  // --- GRID SIZING (NEW) ---
  function parseSize(sizeStr){
    const m = String(sizeStr||"1x1").match(/(\d+)\s*x\s*(\d+)/i);
    if (!m) return { w:1, h:1 };
    return { w: Math.max(1, Number(m[1])), h: Math.max(1, Number(m[2])) };
  }
  function gridDimForSize(sizeStr){
    const { w, h } = parseSize(sizeStr);
    const plant = Math.max(w, h);
    if (plant >= 3) return 5; // 3x3 mutation -> 5x5 grid
    if (plant === 2) return 4; // 2x2 mutation -> 4x4 grid
    return 3; // 1x1 -> 3x3 grid
  }

  function idxRC(dim, r, c){ return (r-1)*dim + (c-1); } // 1-indexed
  function plantAreaMask(dim){
    // dim 3 -> 1x1 plant; dim4 -> 2x2; dim5 -> 3x3
    const plantSize = dim - 2;
    const start = 2;
    const end = start + plantSize - 1;
    const mask = Array(dim*dim).fill(false);
    for (let r=start; r<=end; r++){
      for (let c=start; c<=end; c++){
        mask[idxRC(dim,r,c)] = true;
      }
    }
    return { mask, plantSize, start, end };
  }

  function ringOrder(dim, plantMeta){
    // preferred fill order around plant footprint (center-ish sides first)
    const { start, end, plantSize } = plantMeta;

    // choose a ‚Äúvisual mid row/col‚Äù (for 2x2 we use start row/col to mimic ‚Äúsecond row‚Äù preference)
    const midR = (plantSize % 2 === 1) ? (start + Math.floor(plantSize/2)) : start;
    const midC = (plantSize % 2 === 1) ? (start + Math.floor(plantSize/2)) : start;

    const order = [];

    // side cells adjacent to plant rows (left side then right side)
    for (let r=start; r<=end; r++) order.push(idxRC(dim, r, 1));
    for (let r=start; r<=end; r++) order.push(idxRC(dim, r, dim));

    // top/bottom rows adjacent to plant cols
    for (let c=start; c<=end; c++) order.push(idxRC(dim, 1, c));
    for (let c=start; c<=end; c++) order.push(idxRC(dim, dim, c));

    // corners last
    order.push(idxRC(dim, 1, 1), idxRC(dim, 1, dim), idxRC(dim, dim, 1), idxRC(dim, dim, dim));

    // de-dupe while preserving order
    const seen = new Set();
    const out = [];
    for (const i of order) { if (!seen.has(i)) { seen.add(i); out.push(i); } }

    // bring ‚Äúmid row left/right‚Äù to front for nicer look
    const leftMid  = idxRC(dim, midR, 1);
    const rightMid = idxRC(dim, midR, dim);
    const topMid   = idxRC(dim, 1, midC);
    const botMid   = idxRC(dim, dim, midC);

    const priority = [leftMid, rightMid, topMid, botMid];
    const final = [];
    for (const p of priority) if (out.includes(p)) final.push(p);
    for (const i of out) if (!final.includes(i)) final.push(i);
    return { order: final, cross: { left:leftMid, top:topMid, right:rightMid, bottom:botMid }, midR, midC };
  }

  function recommendLayoutScaled(sizeStr, ingredients, targetName){
    const dim = gridDimForSize(sizeStr);
    const cells = Array(dim*dim).fill("");
    const plant = plantAreaMask(dim);
    const ring = ringOrder(dim, plant);

    // main label cell:
    // odd plant (1 or 3): true center; even plant (2): top-left of plant footprint.
    const mainR = (plant.plantSize % 2 === 1) ? (plant.start + Math.floor(plant.plantSize/2)) : plant.start;
    const mainC = (plant.plantSize % 2 === 1) ? (plant.start + Math.floor(plant.plantSize/2)) : plant.start;
    const mainIndex = idxRC(dim, mainR, mainC);
    cells[mainIndex] = targetName;

    if (!ingredients.length) {
      return { dim, cells, plantMask: plant.mask, mainIndex, note: "No adjacency ingredients required." };
    }

    // requirement-based
    if (ingredients.length === 1 && /All positive crop effects/i.test(ingredients[0].name)) {
      return { dim, cells, plantMask: plant.mask, mainIndex, note: "Requirement-based: All positive crop effects must be present." };
    }

    const distinct = ingredients.length;
    const total = ingredients.reduce((s,it)=>s+(it.count||1),0);

    // expand instances
    const instances = [];
    for (const it of ingredients){
      const c = Math.max(1, Number(it.count||1));
      for (let i=0;i<c;i++) instances.push(it.name);
    }

    // available slots = everything NOT in plant footprint
    const ringSlots = ring.order.filter(i => !plant.mask[i]);
    const capacity = ringSlots.length;

    // total=2: place on mid row left/right
    if (total === 2) {
      const a = ring.cross.left;
      const b = ring.cross.right;
      if (!plant.mask[a]) cells[a] = instances[0] || "";
      if (!plant.mask[b]) cells[b] = instances[1] || "";
      return { dim, cells, plantMask: plant.mask, mainIndex, note: "" };
    }

    // single ingredient total=4: cross (LEFT, TOP, RIGHT, BOTTOM) => matches your ‚Äú4 2 6 8‚Äù idea
    if (distinct === 1 && total === 4) {
      const crossOrder = [ring.cross.left, ring.cross.top, ring.cross.right, ring.cross.bottom];
      for (let i=0;i<4;i++){
        const pos = crossOrder[i];
        if (pos != null && !plant.mask[pos]) cells[pos] = instances[i];
      }
      return { dim, cells, plantMask: plant.mask, mainIndex, note: "" };
    }

    // fit without compression
    if (total <= capacity) {
      for (let i=0;i<Math.min(capacity, instances.length); i++){
        const pos = ringSlots[i];
        cells[pos] = instances[i];
      }
      return { dim, cells, plantMask: plant.mask, mainIndex, note: "" };
    }

    // compress when total exceeds available slots
    const slotCounts = Array.from({length: capacity}, () => ({}));
    let cursor = 0;
    for (const name of instances) {
      const s = cursor % capacity;
      slotCounts[s][name] = (slotCounts[s][name] || 0) + 1;
      cursor++;
    }
    for (let i=0;i<capacity;i++){
      const pos = ringSlots[i];
      const entries = Object.entries(slotCounts[i]);
      if (!entries.length) continue;
      cells[pos] = entries
        .sort((a,b)=>b[1]-a[1] || a[0].localeCompare(b[0]))
        .map(([n,c]) => `${c}x ${n}`)
        .join(" + ");
    }
    return { dim, cells, plantMask: plant.mask, mainIndex, note: `Counts exceed ${capacity} slots; layout compressed.` };
  }

  function gridHtml(dim, cells, plantMask, mainIndex){
    const cols = `repeat(${dim}, 1fr)`;
    return `
      <div class="gridAny" style="grid-template-columns:${cols};">
        ${cells.map((text, i) => {
          const cls = ["cell", plantMask?.[i] ? "plantArea" : "", i===mainIndex ? "centerMain" : ""].join(" ").trim();
          return `
            <div class="${cls}">
              <div class="slotNum">${i+1}</div>
              <div class="slotVal ${text ? "" : "small"}">${text || "‚Äî"}</div>
            </div>
          `;
        }).join("")}
      </div>
    `;
  }

  // Shellfruit special explosion grid (still 3x3)
  function shellfruitSpecialGrid(){
    const dim = 3;
    const cells = Array(9).fill("");
    const plantMask = Array(9).fill(false); // no plant footprint highlight here
    const mainIndex = 4; // slot 5
    cells[4] = "Turtlellini";
    cells[2] = "Blastberry"; // slot 3
    cells[5] = "Blastberry"; // slot 6
    // highlight center cell as the ‚Äúmain‚Äù
    plantMask[4] = true;
    return { dim, cells, plantMask, mainIndex };
  }

  // Godseed special 5x5 requirement grid (keep as you asked)
  function godseedSpecialGrid5(){
    const dim = 5;
    const cells = Array(25).fill("");
    const plant = plantAreaMask(dim);
    const mainIndex = idxRC(dim, 3, 3);
    cells[mainIndex] = "Godseed";
    cells[idxRC(dim,1,3)] = "Shadevine";
    cells[idxRC(dim,3,5)] = "Thornshade";
    cells[idxRC(dim,5,3)] = "Gloomgourd";
    cells[idxRC(dim,3,1)] = "Cocoa Beans";
    cells[idxRC(dim,1,1)] = "Mushroom (Red/Brown)";
    return { dim, cells, plantMask: plant.mask, mainIndex };
  }

  // Default ingredients for normal mutations
  function ingredientsForMutation(name){
    const m = INDEX.get(name);
    if (!m) return [];
    return parseIngredients(m.spread);
  }

  // Build standard (horizontal) recipe tree (recursive)
  function buildStandardTree(rootName){
    const visiting = new Set();
    function nodeFor(name, count){
      const isMut = mutationNamesSet.has(name);
      const mut = isMut ? INDEX.get(name) : null;

      const node = {
        id: name,
        label: name,
        count: count ?? 1,
        kind: isMut ? "mutation" : "base",
        rarity: mut?.rarity || (isMut ? "UNKNOWN" : "BASE"),
        meta: mut || null,
        url: null,
        children: []
      };

      if (!isMut) return node;

      const key = name.toLowerCase();
      if (visiting.has(key)) return node; // avoid cycles
      visiting.add(key);

      const ing = ingredientsForMutation(name);
      for (const it of ing) node.children.push(nodeFor(it.name, it.count || 1));

      visiting.delete(key);
      return node;
    }
    return nodeFor(rootName, 1);
  }

  // Special straight-line chains
  function makeNode({ id, label, kind, rarity, url, meta, glow, count }) {
    return { id, label: label ?? id, kind, rarity, url: url ?? null, meta: meta ?? null, glow: !!glow, count: count ?? 1 };
  }

  function specialChain(rootName){
    if (rootName === "Shellfruit") {
      return [
        makeNode({ id:"Shellfruit", kind:"mutation", rarity: INDEX.get("Shellfruit")?.rarity || "EPIC", meta: INDEX.get("Shellfruit") }),
        makeNode({ id:"Explode Turtlellini with 2x Blastberry", kind:"action", rarity:"ACTION" }),
        makeNode({ id:"Turtlellini", kind:"mutation", rarity: INDEX.get("Turtlellini")?.rarity || "EPIC", meta: INDEX.get("Turtlellini") }),
        makeNode({ id:"Blastberry", label:"Blastberry (x2)", kind:"mutation", rarity: INDEX.get("Blastberry")?.rarity || "RARE", meta: INDEX.get("Blastberry"), count: 2 }),
      ];
    }

    if (rootName === "Godseed") {
      return [
        makeNode({ id:"Godseed", kind:"mutation", rarity: INDEX.get("Godseed")?.rarity || "LEGENDARY", meta: INDEX.get("Godseed") }),
        makeNode({ id:"Requirement: all positive crop effects present", kind:"action", rarity:"ACTION" }),
      ];
    }

    if (rootName === "Jerryflower") {
      return [
        makeNode({ id:"Jerryflower", kind:"mutation", rarity: INDEX.get("Jerryflower")?.rarity || "LEGENDARY", meta: INDEX.get("Jerryflower") }),
        makeNode({ id:"Fertilized Jerryseed", kind:"item", rarity:"ITEM" }),
        makeNode({ id:"Dirty | Unripe Jerryseed + Dirt Guy", kind:"link", rarity:"LINK", url: DIRT_GUY_URL, glow:true }),
        makeNode({ id:"Talk to Xalx in Goblin Holdout", kind:"action", rarity:"ACTION" }),
        makeNode({ id:"Unfulfilled Jerryseed + Mysterious Crop", kind:"item", rarity:"ITEM" }),
        makeNode({ id:"Chance to obtain by Jerry in ‚è£ The Garden", kind:"action", rarity:"ACTION" }),
      ];
    }

    return [];
  }

  function tooltipHtmlForNode(n){
    const isMutation = n.kind === "mutation" && mutationNamesSet.has(n.id);
    const m = isMutation ? (n.meta || INDEX.get(n.id)) : null;
    const badge = isMutation ? (m?.rarity || n.rarity || "UNKNOWN") : (n.rarity || n.kind);
    const head = `<div class="name">${safeText(n.label)}<span class="tag">${badge}</span></div>`;

    // link node (Dirt Guy)
    if (n.kind === "link" && n.url) {
      return `
        ${head}
        <div class="meta">
          <div>Type: link</div>
          <div><b>Click the blue-glow node</b> to open Dirt Guy: <span>${safeText(n.url)}</span></div>
        </div>
      `;
    }

    // mutation details
    let details = "";
    if (isMutation && m) {
      details = `
        <div class="meta" style="margin-top:6px;">
          ${m.size ? `<div>Size: ${m.size}</div>` : ""}
          ${m.surface ? `<div>Growth Surface: ${m.surface}</div>` : ""}
          ${m.spread ? `<div>Spreading Conditions: ${m.spread}</div>` : ""}
          ${m.effects ? `<div>Effects: ${m.effects}</div>` : ""}
        </div>
      `;
    }

    // SPECIAL: Shellfruit tooltip includes explosion grid
    if (isMutation && n.id === "Shellfruit") {
      const g = shellfruitSpecialGrid();
      return `
        ${head}
        <div class="meta">
          <div><b>Special:</b> Explode Turtlellini with <b>2x</b> Blastberry to obtain Shellfruit.</div>
        </div>
        ${details}
        <div class="sep"></div>
        <div class="meta"><div><b>Explosion placement (3√ó3)</b></div></div>
        <div class="gridTitle">Turtlellini at 5, Blastberry at 3 and 6.</div>
        ${gridHtml(g.dim, g.cells, g.plantMask, g.mainIndex)}
        <div class="hint" style="margin-top:6px;">Hover Turtlellini / Blastberry nodes in the line to see their normal crafting trees.</div>
      `;
    }

    // SPECIAL: Godseed tooltip includes 5x5 requirement grid
    if (isMutation && n.id === "Godseed") {
      const g = godseedSpecialGrid5();
      return `
        ${head}
        <div class="meta">
          <div><b>Special:</b> Godseed can grow if every positive crop effect is present.</div>
          <div>Recommended set (credit: Fandom): Shadevine, Thornshade, Gloomgourd, Cocoa Beans, and Red/Brown Mushroom.</div>
          <div class="hint">Base crops list: ${BASE_CROPS.join(", ")}</div>
        </div>
        ${details}
        <div class="sep"></div>
        <div class="meta"><div><b>5√ó5 layout (Godseed is 3√ó3)</b></div></div>
        <div class="gridTitle">Middle 3√ó3 is the plant area (green). Requirements placed around for visibility.</div>
        ${gridHtml(g.dim, g.cells, g.plantMask, g.mainIndex)}
      `;
    }

    // SPECIAL: Jerryflower tooltip (no grid)
    if (isMutation && n.id === "Jerryflower") {
      return `
        ${head}
        <div class="meta">
          <div><b>Special chain:</b> Plant a <b>Fertilized Jerryseed</b> ‚Üí Dirty Unripe Jerryseed + Dirt Guy ‚Üí Xalx (Goblin Holdout) with Unfulfilled Jerryseed + Mysterious Crop.</div>
          <div>Unfulfilled Jerryseed: chance after serving <span class="gold">Jerry</span> in ‚è£ The Garden.</div>
        </div>
        ${details}
        <div class="sep"></div>
        <div class="hint">Click the blue-glow ‚ÄúDirty | Unripe Jerryseed + Dirt Guy‚Äù node to open the Dirt Guy fandom page.</div>
      `;
    }

    // DEFAULT mutation tooltip (SCALED GRID)
    if (isMutation && m) {
      const ingredients = ingredientsForMutation(n.id);
      const lay = recommendLayoutScaled(m.size, ingredients, n.id);

      const ingList = ingredients.length
        ? `<ul>${ingredients.map(it => `<li>${it.count}x ${it.name}</li>`).join("")}</ul>`
        : `<div class="hint">(No adjacency ingredients)</div>`;

      return `
        ${head}
        <div class="meta"><div>Type: mutation</div></div>
        ${details}
        <div class="sep"></div>
        <div class="meta"><div><b>Ingredients needed</b></div></div>
        ${ingList}
        <div class="sep"></div>
        <div class="gridTitle">${lay.dim}√ó${lay.dim} combine layout (plant footprint highlighted green)</div>
        ${gridHtml(lay.dim, lay.cells, lay.plantMask, lay.mainIndex)}
        ${lay.note ? `<div class="hint" style="margin-top:6px;">${lay.note}</div>` : ""}
      `;
    }

    // Action nodes: ONLY color Jerry gold on that one exact line
    if (n.kind === "action") {
      const label = safeText(n.label);
      const txt = (label === "Chance to obtain by Jerry in ‚è£ The Garden")
        ? label.replace("Jerry", '<span class="gold">Jerry</span>')
        : label;
      return `${head}<div class="meta"><div>${txt}</div></div>`;
    }

    // other nodes
    return `${head}<div class="meta"><div>Type: ${n.kind}</div></div>`;
  }

  function renderEmpty(){
    svg.selectAll("*").remove();
    const w = svg.node().clientWidth || 800;
    const h = svg.node().clientHeight || 500;
    const g = svg.append("g");
    g.append("text")
      .attr("x", w/2).attr("y", h/2)
      .attr("text-anchor", "middle")
      .attr("fill", "rgba(231,236,255,.75)")
      .attr("font-size", 16)
      .attr("font-weight", 800)
      .text("Search for a mutation to start");
    g.append("text")
      .attr("x", w/2).attr("y", h/2 + 26)
      .attr("text-anchor", "middle")
      .attr("fill", "rgba(231,236,255,.55)")
      .attr("font-size", 12)
      .text("Special straight-line views: Shellfruit, Godseed, Jerryflower.");
    countsEl.textContent = "‚Äî";
    updateUI();
  }

  // Standard horizontal tree
  function renderHorizontalTree(rootName){
    svg.selectAll("*").remove();
    const width = svg.node().clientWidth;
    const height = svg.node().clientHeight;

    const treeObj = buildStandardTree(rootName);
    const root = d3.hierarchy(treeObj, d => d.children);

    const layout = d3.tree().size([height - 40, width - 260]);
    layout(root);

    const g = svg.append("g").attr("transform", "translate(130,20)");
    svg.call(d3.zoom().scaleExtent([0.35, 2.7]).on("zoom", (ev) => g.attr("transform", ev.transform)));

    g.selectAll("path.link")
      .data(root.links())
      .enter()
      .append("path")
      .attr("fill","none")
      .attr("stroke","rgba(255,255,255,.18)")
      .attr("stroke-width",1.6)
      .attr("d", d3.linkHorizontal().x(d => d.y).y(d => d.x));

    const nodes = g.selectAll("g.node")
      .data(root.descendants())
      .enter()
      .append("g")
      .attr("transform", d => `translate(${d.y},${d.x})`);

    nodes.append("circle")
      .attr("r", d => d.depth === 0 ? 9 : (d.data.kind === "mutation" ? 6 : 4.7))
      .attr("fill", d => nodeColor(d.data.kind, d.data.rarity))
      .attr("stroke","rgba(255,255,255,.25)")
      .style("cursor", d => d.data.kind === "mutation" ? "pointer" : "default")
      .on("mousemove", (ev, d) => showTip(tooltipHtmlForNode(d.data), ev.clientX, ev.clientY))
      .on("mouseleave", hideTip)
      .on("click", (ev, d) => {
        if (d.data.kind !== "mutation") return;
        navigateTo(d.data.id, { setBaseline: false });
      });

    nodes.append("text")
      .attr("dx", d => d.children ? -10 : 10)
      .attr("dy", 4)
      .attr("text-anchor", d => d.children ? "end" : "start")
      .attr("fill","rgba(231,236,255,.92)")
      .style("font-weight", d => d.depth === 0 ? 900 : 520)
      .text(d => d.depth === 0 ? d.data.label : (d.data.count > 1 ? `${d.data.count}x ${d.data.id}` : d.data.id));

    countsEl.textContent = `Tree nodes: ${root.descendants().length} ‚Ä¢ links: ${root.links().length}`;
  }

  // Special straight-line view
  function renderSpecialLine(rootName){
    svg.selectAll("*").remove();
    const width = svg.node().clientWidth;
    const height = svg.node().clientHeight;

    const chain = specialChain(rootName);
    const g = svg.append("g");
    svg.call(d3.zoom().scaleExtent([0.35, 2.7]).on("zoom", (ev) => g.attr("transform", ev.transform)));

    // defs: blue glow for Dirt Guy node
    const defs = svg.append("defs");
    const filt = defs.append("filter").attr("id","blueGlow").attr("x","-50%").attr("y","-50%").attr("width","200%").attr("height","200%");
    filt.append("feGaussianBlur").attr("stdDeviation","3").attr("result","blur");
    filt.append("feMerge").selectAll("feMergeNode")
      .data(["blur","SourceGraphic"])
      .enter()
      .append("feMergeNode")
      .attr("in", d => d);

    const x = width/2;
    const y0 = 80;
    const dy = Math.min(110, Math.max(85, (height - 140) / Math.max(1, chain.length - 1)));

    chain.forEach((n,i) => { n._x = x; n._y = y0 + i*dy; n._i = i; });

    const links = chain.slice(1).map((n,i) => ({ a: chain[i], b: n }));

    g.selectAll("line.link")
      .data(links)
      .enter()
      .append("line")
      .attr("x1", d => d.a._x).attr("y1", d => d.a._y)
      .attr("x2", d => d.b._x).attr("y2", d => d.b._y)
      .attr("stroke", "rgba(255,255,255,.18)")
      .attr("stroke-width", 2);

    const nodes = g.selectAll("g.node")
      .data(chain)
      .enter()
      .append("g")
      .attr("transform", d => `translate(${d._x},${d._y})`);

    nodes.append("circle")
      .attr("r", d => d._i === 0 ? 10 : (d.kind === "mutation" ? 7 : 6))
      .attr("fill", d => nodeColor(d.kind, d.rarity))
      .attr("stroke", d => d.glow ? "rgba(120,170,255,.95)" : "rgba(255,255,255,.25)")
      .attr("stroke-width", d => d.glow ? 2.5 : 1.2)
      .attr("filter", d => d.glow ? "url(#blueGlow)" : null)
      .style("cursor", d => (d.kind === "mutation" || d.kind === "link") ? "pointer" : "default")
      .on("mousemove", (ev, d) => showTip(tooltipHtmlForNode(d), ev.clientX, ev.clientY))
      .on("mouseleave", hideTip)
      .on("click", (ev, d) => {
        if (d.kind === "link" && d.url) {
          window.open(d.url, "_blank", "noopener,noreferrer");
          return;
        }
        if (d.kind === "mutation" && mutationNamesSet.has(d.id)) {
          navigateTo(d.id, { setBaseline: false });
        }
      });

    // label: ONLY gold Jerry on the one exact line
    nodes.append("text")
      .attr("text-anchor","middle")
      .attr("dy", d => d._i === 0 ? -16 : -14)
      .attr("fill","rgba(231,236,255,.92)")
      .style("font-weight", d => d._i === 0 ? 900 : 650)
      .each(function(d){
        const el = d3.select(this);
        const label = String(d.label || d.id);

        if (label === "Chance to obtain by Jerry in ‚è£ The Garden") {
          const [a, b] = label.split("Jerry");
          el.append("tspan").text(a).attr("fill", "rgba(231,236,255,.92)");
          el.append("tspan").text("Jerry").attr("fill", "#ffd56a").style("font-weight", 900);
          el.append("tspan").text(b).attr("fill", "rgba(231,236,255,.92)");
        } else {
          el.text(label);
        }
      });

    countsEl.textContent = `Line nodes: ${chain.length} ‚Ä¢ links: ${links.length} ‚Ä¢ special`;
  }

  function render(){
    hideTip();
    updateUI();

    if (!ROOT) {
      setStatus("Search for a mutation to start.");
      renderEmpty();
      return;
    }

    setStatus("Ready");
    if (SPECIAL_LINE.has(ROOT)) renderSpecialLine(ROOT);
    else renderHorizontalTree(ROOT);
  }

  function bestMatch(q){
    const s = safeText(q).toLowerCase();
    if (!s) return null;
    const exact = NAMES.find(n => n.toLowerCase() === s);
    if (exact) return exact;
    const starts = NAMES.find(n => n.toLowerCase().startsWith(s));
    if (starts) return starts;
    const includes = NAMES.find(n => n.toLowerCase().includes(s));
    if (includes) return includes;
    return null;
  }

  function navigateTo(name, { setBaseline }){
    if (!mutationNamesSet.has(name)) return;
    if (setBaseline) BASELINE = name;
    ROOT = name;
    render();
  }

  function go(){
    const m = bestMatch(searchEl.value);
    if (!m) { setStatus("No match."); return; }
    BASELINE = m;
    ROOT = m;
    render();
  }

  function goBackToBaseline(){
    if (!BASELINE) return;
    ROOT = BASELINE;
    render();
  }

  goBtn.addEventListener("click", go);
  backBtn.addEventListener("click", goBackToBaseline);
  searchEl.addEventListener("keydown", (e) => { if (e.key === "Enter") go(); });

  // Ctrl+Z: back to baseline (don‚Äôt steal undo while typing)
  document.addEventListener("keydown", (e) => {
    const isCtrlZ = (e.ctrlKey || e.metaKey) && !e.shiftKey && (e.key === "z" || e.key === "Z");
    if (!isCtrlZ) return;
    const ae = document.activeElement;
    const typing = ae && (ae.tagName === "INPUT" || ae.tagName === "TEXTAREA" || ae.isContentEditable);
    if (typing) return;
    if (BASELINE && ROOT && ROOT !== BASELINE) {
      e.preventDefault();
      goBackToBaseline();
    }
  });

  window.addEventListener("resize", render);

  // Start clean
  searchEl.value = "";
  BASELINE = null;
  ROOT = null;
  updateUI();
  renderEmpty();
})();
</script>
</body>
</html>
